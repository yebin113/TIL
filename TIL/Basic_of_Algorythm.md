# 20230731 월: List1

### 알고리즘
  - 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법.
  - 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함.
  - 표현하는 방법은 크게 의사코드/순서도가 존재함.
  - APS과정: 보다 좋은 알고리즘을 이해하고 활용하는 것.
  
  - ##### 무엇이 좋은 알고리즘인가?
    - 정확성: 얼마나 정확하게 동작하는가
    - 작업량: 얼마나 적은 연산으로 원하는 결과를 얻어내는가
    - 메모리 사용량: 얼마나 적은 메모리를 사용하는가
    - 단순성: 얼마나 단순한가
    - 최적성: 더 이상 개선할 여지없이 최적화되었는가

  - 주어진 문제를 해결하기 위해 여러 개의 다양한 알고리즘이 기능.

  - ##### 시간복잡도: 알고리즘의 작업량을 표현할 떄
    - 실제 걸리는 시간을 측정
    - 실행되는 명령문의 개수를 계
    - 
    - ###### 빅-오(O) 표기법
      - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
      - 계수는 생략하여 표시
      - 예를들어 O(n), O(n^2) 형태로 표시
      - 대략 10억번의 연산을 하면 1초

### 배열(Array): 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

  - ##### 배열의 필요성
    - 프로그램 내에서 여러개의 변수가 필요할 때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적
    - 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있음.
    - 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.

  - ##### 1차원 배열
    - 1차원 배열의 선언: 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성
    - 이름: 프로그램에서 사용할 배열의 이름
      ```py
      # 생성 방법
      Arr = list()
      Arr = []
      Arr = [1, 2, 3]
      Arr = [0] * 10
      
      # 접근 방법
      Arr[0]
      arr[idx]
      ```

# 2023-08-01-화: List1
### 정렬: 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰값 혹은 그 반대의 순서대로 재배열 하는 것.
  - 키: 자료를 정렬하는 기준이 되는 특정 값

  - ##### 대표적인 정렬 방식의 종류 
    - 버블 정렬
    - 카운팅 정렬
    - 선택 정렬
    - 퀵 정렬
    - 삽입 정렬
    - 병합 정렬

  - ##### 버블 정렬: 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
    - 정렬 과정
      - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
      - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
      - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블정렬이라고 한다.

    - 시간 복잡도: O(n^2)

  - ##### 카운팅 정렬: 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하며, 선형 시간에 정렬하는 효율적인 알고리즘.
    - 인덱스 자체를 값으로 활용하기 위한 정렬.
    - 제한 사항
      - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능: 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.
      - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.
    - 시간 복잡도: O(n+k): n은 리스트 길이, k는 정수의 최댓값
    - 정렬 과정
      -  
  - ##### 완전검색: 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법: Bruth-force
    - 모든 경우의 수를 테스트한 후, 최종 해법 도출.
    - 일반적으로 경우의 수가 상대적으로 작을 때 유용.
    - 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
    - 우선 완전 검색으로 접근하여 해답을 도출한 후 성능 개선을 위해 다른 알고리즘 사용하고 해답 확인하는 방법
  
  - ##### 순열: 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것.
    - ex)

  - ##### 탐욕 알고리즘(Greedy): 최적해를 구하는 데 사용되는 근시안적인 방법
    - 여러 경우 중 하나를 결정해야 할 때마나 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다
    - 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
    - 일반적으로, 머릿속에 떠오르는 생각을 검증없이 바로 구현하면 그리지 접근이 된다.
    - 동작과정
      - 1) 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해집합에 추가한다.
      - 2) 실행 가능성 검사: 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
      - 3) 해 검사: 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1)의 해 선택부터 다시한다.

# 2023-08-02-수: Array2
### 2차원 배열: 1차원 리스트를 묶어놓은 리스트
  - 2차원 이상의 다차원 리스트는 차원에 따라 Index를 선언
  - 2차원 리스트의 선언: 세로길이, 가로길이를 필요로 함
  - 파이썬 에서는 데이터 초기화를 통해 변수선언과 초기화가 가능함
    ```py
    arr = [[0, 1, 2, 3], [4, 5, 6, 7]] 
    #2행 4열의 2차원 List
    ```
    ** 참고 2차원 입력받기
    ```py
    # 3 N번동안 리스트 받기
    # 1 2 3
    # 4 5 6
    # 7 8 9
    
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    ```
  - 배열 순회
    - 행 우선 순회 
      ```py
      for i in range(N):
        for j in range(M):
          print(arr[i][j])
      ```
    - 열 우선 순회
      ```py
      for j in range(M):
        for i in range(N):
            print(arr[i][j])
      ```
    - 지그재그 순회
      ```py
      for i in range(N):
        for j in range(M):
            print(arr[i][j + (M-1-2*j) * (i%2)])
      ```
### 델타를 이용한 2차 배열 탐색
  - 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
    ```py
    # delta
    '''
    3
    1 2 3
    4 5 6
    7 8 9
    '''
    di = [0, 1, 0, -1]
    dj = [1, 0, -1, 0]
    # 입력받기
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    # 십자가 형태로 합을 구하고 최대값 구하기
    
    max_v = 0 # 모든 원소가 0이상이라면...
    for i in range(N): # 모든 원소 arr[i][j]에 대해...
        for j in range(N):
            s = arr[i][j] # 일단 센터값으로 초기화
            for k in range(4): # 상하좌우 이동
                ni = i + di[k]
                nj = j + dj[k]
                # 배열 내부에 있으면
                if 0 <= ni < N and 0 <= nj < N:
                    s += arr[ni][nj]
            # 주변원소의 합을 구하고 최댓값 찾기
            if max_v < s:
                max_v = s
    ```

### 전치행렬: Transformation
  - 대각선 기준으로 자리 바꾸는 것
    ```py
    arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # 3*3 행렬
    
    for i in range(3):
      for j in range(3):
        if i < j: #상호 교환
          arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
    ```

  - list_search 방법

    ```python
    # 행열 탐색 연습	
      
    # 0으로 초기화 된 N * M의 2차원 배열 생성하기.
    m = 3
    n = 3

    arr = []
    for i in range(n):
        row = [0] * m
        arr.append(row)
    print(arr)

    # 행 우선 순회를 다른 것보다 우선시 하여 학습하자!
    num_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    print(num_list)

    # 1. 행 우선 순회 정상적으로 진행되는지 확인
    for r in range(len(num_list)):
        for c in range(len(num_list[0])):
            print(f'{num_list[r][c]}', end=' ') # 1 2 3 4 5 6 7 8 9
    print()

    # 2. 열 우선 순회
    for c in range(len(num_list[0])):
        for r in range(len(num_list)):
            print(f'{num_list[r][c]}', end=' ') # 1 4 7 2 5 8 3 6 9
    print()

    # 3. 역-행 우선 순회
    for i in range(n):
        for j in range(m-1, -1, -1):
            print(num_list[i][j], end=' ') # 3 2 1 6 5 4 9 8 7
    print()

    # 4. 역-열 우선 순회
    for j in range(m):
        for i in range(n-1, -1, -1):
            print(num_list[i][j], end=' ') # 7 4 1 8 5 2 9 6 3
    print()

    # 5. 가장자리의 합
    def edge_sum(arr):
        # 순회를 하면서, 2차원 리스트의 가장자리에 있는 원소들을 합한다.
        edge_sum_result = 0
        for i in range(len(arr)):
            for j in range(len(arr[0])):
                if (i == 0) or (i == len(arr) -1) or (j == 0) or (j == len(arr[0]) - 1):
                    # print(arr[i][j])
                    edge_sum_result += arr[i][j]

        return edge_sum_result


    result = edge_sum(num_list)
    print(result) # 40

    # 6. 델타 탐색
    # 탐색 순서는 주어진 조건에 맞춰서 구현해야 한다.
            # 상 하 좌 우
    d_row = [-1, 1, 0, 0]
    d_col = [0, 0, -1, 1]
    # 대각선
          # 좌상단 / 좌하단 / 우상단 / 우상단
    dxy = [(-1, -1), (-1, 1), (1, -1), (1, 1)]

    # 벽을 세워야 한다. = 주어진 2차원 리스트의 범위를 벗어나지 않도록 제한을 두는 행위
    # 1. 벽에 제한을 두는 데, 벽을 넘어가는 경우, 아무것도 하지 않는다.
    # 2. 벽을 넘어가지 않는 경우에만 기능을 수행한다.
    x = 0
    y = 1
    dx = [-1, 1, 0, 0]
    dy = [0, 0, -1, 1]
    N = 5
    for d in range(4):
        # 다음에 탐색할 좌표 담기.
        nx = x + dx[d]
        ny = y + dy[d]

        # 바뀐 좌표가 map을 벗어나는지 확인.
        if nx < 0 or nx >= N or ny < 0 or ny >=N:
            # map을 벗어나는 경우 일로 들어옴.
            continue

        # map을 벗어나지 않는 경우
        if 0 <= nx < N and 0 <= ny < N:
            # map을 벗어나지 않는 경우 일로 들어옴.
            continue

    def isSafeArea(nx, ny, N):
        if 0 <= nx < N and 0 <= ny < N:
            # map을 벗어나지 않는 경우 일로 들어옴.
            return True
        return False

    ```

# 2023-08-03-목: Array2-2 

### 부분집합 합 문제
  - 유한개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그​ 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
  - 예를 들어, [-7, -3, -2, 5, 8]이라는 집합이 있을 떄, [-3, -2, 5]는 집합의 부분집합 이면서 (-3) + (-2) + 5 = 0이므로 이 경우의 답은 참이 된다.		
  - 완전검색 기법으로 부분집합 합 문제를 풀기 위해서는, 우선 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 한다.
  - 주어진 집합의 부분집합을 생성하는 방법에 대해서 생각해보자.
  - 부분집합의 수
    - 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n개
    - 한개의 원소당 포함되거나(1)/포함되지않거나(0) 두가지 경우 존재 
    - 1과 0으로 이루어진 다른 배열(비트)을 만들어서 보조지표로 사용.
    - ##### 비트 배열
    - 비트 배열 4칸짜리 만들기.
      ```py
      def print_subset(bit, arr, n):
        for i in range(n):
          if bit[i]:
            print(arr[i], end=' ')
        print(bit)

      arr = [1, 2, 3, 4]
      bit = [0, 0, 0, 0]
      for i in range(2):
        bit[0] = i
        for j in range(2):
          bit[1] = j 
          for k in rage(2):
            bit[2] = k
            for l in range(2):
              bit[3] = l
              print_subset(bit, arr, 4)
      # 이 방법은 원소의 갯수마다 for문이 증가한다는 단점이 있음.
      ```
      - ##### 비트 연산자
        - &: 비트 단위로 AND 연산을 한다.
        - |: 비트 단위로 OR 연산을 한다.
        - <<: 피연산자의 비트 열을 왼쪽으로 이동시킨다.
        - '>>': 피연산자의 비트 열을 오른쪽으로 이동시킨다.
        - ##### << 연산자
          - 1 << n: 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
        - ##### & 연산자
          - i & (i << j): i의 j번째 비트가 1인지 아닌지를 검사한다.
        - 보다 간결하게 부분집합을 생성하는 방법
          ```py
          arr = [3, 6, 7, 1, 5, 4]

          n = len(arr) # n: 원소의 개수

          for i in range(1<<n): # 2**n: 부분집합의 개수
            for j in range(n):  # 원소의 개수만큼 비트를 비교
              if i & (1<<j):    # i의 j번째 비트가 1인 경우
                print(arr[j], end=", ") # j번째 원소 출력
            print()
          print()          
          ```   
  
  ### 검색(search): 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업 - 순차검색 / 이진검색 / 해쉬
  
  - ##### 순차검색
    - 일렬로 되어 있는 자료를 순서대로 검색하는 방법
      - 가장 간단하고 직관적인 검색 방법
      - 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용함.
      - 알고리즘으 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행시간이 급격이 비효율적임

    - 정렬되어있지 않은 경우
      - 검색과정
        - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.
        - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.
        - 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패
        - 찾고자 하는 원소의 순서에 따라 비교회수가 결정 됨.
        - 시간 복잡도: O(n)
    
    - 정렬되어있는 경우
      - 장점: 검색 대상이 없음을 일찍 찾을 수 있음
      - 항상 끝까지 검색을 해주지 않아도 됨.
  
  - ##### 이진 검색(Binary Search): 계속 반으로 잘라가면서 탐색
    - 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
      - 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함
    - 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.
    - 검색과정
      - 1. 자료의 중앙에 있는 원소를 고른다.
      - 2. 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.
      - 3. 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행한다.
      - 4. 찾고자 하는 값을 찾을 때까지 1~3의 과정을 반복한다.
    - 구현
      - 검색 범위의 시작점과 종료점을 이용하여 검색을 반복 수행한다.
      - 이진 검색의 경우, 자료에 삽입이나 삭제가 발생했을 때 배열의 상태를 항상 정렬 상태로 유지하는 추가 작업이 필요하다.
        ```py
        def binarySearch(arr, N ,key):
          start = 0
          end = N-1
          while start <= end:
            middle = (start + end) // 2
            if arr[middle] == key: # 검색 성공
              return True
            elif arr[middle] > key:
              end = middle - 1
            else:
              start = middle + 1
          return False # 검색 실패
        ``` 
  - ##### 인덱스

  - ##### 선택정렬(Selection Sort)
    - 주어진 자료들 중 가장 작은 값의 우너소부터 차례대로 선택하여 위치를 교환하는 방식
    - 정렬과정
      - 주어진 리스트 중에서 최소값을 찾는다.
      - 그 값을 리스트의 맨 앞에 위치한 값을 교환한다.
      - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.
        ```py
        def selectionSort(a, N):
          for i in range(N-1):
            minIdx = i
            for j in range(i+1, N):
              if a[minIdx] > a[j]:
                minIdx = j
            a[i], a[minIdx] = a[minIdx], a[i]
        ``` 
      - 저장되어 있는 자료로부터 K번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘
      - 선택과정
        - 정렬 알고리즘을 이용하여 자료 정렬하기
        - 원하는 순서에 있는 원소 가져오기
      - K번째로 작은 원소를 찾는 알고리즘
        - 1번부터 K번째까지 작은 원소들을 찾아 배열의 앞쪽으로 이동시키고, 배열의 K번쨰를 반환
        ```py
        def select(arr, k):
          for i in range(0, k):
            minIndex = i
            for j in (i+1, len(arr)):
              if arr[minIndex] > arr[j]:
                minIndex = j
            arr[j], arr[minIndex] = arr[minIndex], arr[j]
          
          return arr[k-1]

        ``` 

# 2023-08-07-월: String01
### 문자의 표현: 메모리는 숫자만 저장할 수 있기에 문자를 숫자로 바꾼 뒤 저장.

### 아스키코드(ASCII): 문자 인코딩 표준
  - 확장 아스키

### 유니코드: 다국어 문자 처리를 위한 표준
  - 유니코드를 사용하기 위해서는 적당한 외부 인코딩이 필요
  - 유니코드도 다시 Character Set으로 분류 됨.

### 문자열의 분류
  - string(fixed length / variable length(length controlled / delimited))
  - ##### Python에서의 문자열 처리
    - 텍스트 데이터의 취급방법이 통일 되어 있음
    - 문자열 기호 
      - ' ', " ", ''' ''', """ """
    - 시퀀스 자료형으로 문륟함,
    - 튜플과 같이 요소값을 변경 할 수 없음.

  - ##### 문자열 뒤집기
    - 반복 수행을 하면서 자리를 바꿔가며 반복
    - a l g o r y t h m 에서
    - index를 이용해 a 와 m을 비교
    - l과 h를 비교
    - g와 t를 비교
    - o와 y를 비교

  - ##### == 연산자와 is 연산자를 제공 # 둘은 다르게 적용 됨.
    - == 연산자는 내부적으로 __eq__()를 호출 
      ```py
      s1 = 'abc'
      s2 = 'abc'
      s5 = s1[:2]+'c'

      's1 == s5' # 내용물 비교
      's1 == s2'
      'but'
      's1 is not s5' # 완전히 동일하게 입력이 되었는지 비교 
      's1 is s2'
      ```

# 2023-08-08-화: String02

### 패턴 매칭
  - ##### Brute Force(완전 탐색)
    - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작
    - flag 변수 -> 찾은 경우 그대로 1 일치하지 않는 경우 0으로 변환
    - i와 j가 같이 증가하며 체크하는 패턴
      ```py
      p = 'is' # 찾을 패턴
      t = 'This is a book~!' # 전체 텍스트
      M = len(p) # 찾을 패턴의 길이
      N = len(t) # 전체 텍스트의 길이 
      
      def BruteForce(p, t):
        i = 0 # t의 인덱스
        j = 0 # p의 인덱스
        while j < M and i < N:
          if t[i] != p[j]:
            i = i - j # 갔던 만큼 뒤로 옴
            j = -1 # 맨 앞으로
          i += 1 # 한 칸 앞으로의 효과
          j += 1 # 맨 앞으로
        if j == M:
          return i - M
        else:
          return -1
      ```
    - 시간 복잡도
      - O(MN)으로 커짐
      - 비교횟수를 줄일 수 있는 방법은?
  
  - ##### KMP 알고리즘
    - 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
    - 패턴을 전처리 하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
    - 시간복잡도:O(M+N) 
    - 표(테이블)를 만들어서 매칭이 실패했을 때 돌아올 곳을 준비해 둔다. 
    - 계산한 위치부터 다시 비교 시작.

  - ##### 보이어-무어 알고리즘
    - 오른쪽에서 왼쪽으로 비교
    - 대부분의 상용 SW에서 채택하고 있는 알고리즘
    - 보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치 하소 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이만큼이 된다.
    - ###### 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재할 경우
      - 패턴에서 일치하는 문자를 찾아서 세 칸을 점프!
    - 입력에 따라 다르지만 일반적으로 O(n)보다 시간이 덜 든다.

# 2023-08-09-수: Stack

### 스택1
 - ##### 스택의 특성
   - 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
   - 스택에 저장된 자료는 선형 구조를 갖는다.
     - 선형구조: 자료 간의 관계가 1대1의 관계를 갖는다.
     - 비선형구조: 자료 간의 관계가 1대N의 관계를 갖는다.
    - 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.
    - 마지막에 삽입한 자료를 가장 먼저 꺼낸다. 후입선출 이라고 부른다.
      - 1,2,3 순으로 자료를 삽입한 후 거내면 3,2,1 순으로 꺼낼 수 있다. 
    - 배열을 저장소로 사용(list)
    - 스택에서 마지막 삽입된 원소의 위치를 top이라 부른다.
    
  - ##### 연산
    - 삽입: 저장소에 자료를 저장한다. push
    - 삭제: 저장소에서 자료를 꺼내고 반환. pop
    - 스택이 공백인지 아닌지: isEmpty
    - 스택의 top에 있는 원소를 반환: peek

  - ##### 스택의 삽입/삭제 과정
    - 후입 선출!
    - pop을 하면 top위치에 있는 원소를 꺼내고 top은 하나 내림.

  - ##### 스택의 push 알고리즘
    - append 메소드를 통해 리스트의 마지막에 데이터를 삽입
    - append 메소드는 속도가 좀 느림.
      ```py
      def push(item, size):
        global top
        top += 1
        if top == size:
          print('overflow!')
        else:
          stack[top] = item
        
        size = 10
        stack = [0] * size
        top = -1

        push(10, size)
        top += 1
        stack[top]
      ``` 
  
  - ##### 스택의 pop 알고리즘
    - 마지막 데이터를 반환 
      ```py
      def pop():
        global top
        if top == -1:
          print('underflow')
          return 0
        else:
          top -= 1
          return stack[top+1]

      print(pop())
      if top > -1:
        top -= 1
        print(stack[top+1])
      ``` 
  
  - ##### 스택 구현 고려사항
    - 1차원 배열을 사용하여 구현할 경우 구현이 용이하다는 장점이 있지만 스택의 크기를 변경하기가 어렵다는 단점이 있다.
    - 이를 해결하기 위한 방법으로 저장소를 동적으로 할당하여 스택을 구현하는 방법이 있다. 동적 연결리스트를 이용하여 구현하는 방법을 의미한다. 구현이 복잡하다는 단점이 있지만 메모리를 효율적으로 사용한다는 장점을 갖는다. 스택의 동적 구현은 생략한다.

  - ##### Function Call
    - 함수 호출과 복귀에 따른 전체 프로그램의 수행 순서를 관리
      - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로, 후입선출 구조의 스택을 이용하여 수행순서 관리
      - 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입
      - 합수의 실행이 끝나면 시스템 스택의 top원소를 삭제 하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀
      - 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 된다.

  - ##### 재귀호출
    - 자기 자신을 호출하여 순환 수행되는 것.
    - -> 서로 다른 함수를 호출하는 것 처럼 생각 해야 함.
    - 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성
    - 예시(factorial)
      ```py
      '''
      n! = n * (n-1)!
      (n-1)! = (n-1) * (n-2)!
      .
      .
      .
      2! = 2 * 1!
      1! = 1
      '''
      ```
    - 재귀호출을 돌며 스택에 쌓임
    - 따라서 입력과 반대로 곱해짐(후입 선출)

    - ##### Memoization - 재귀 관련
      - 피보나치 수를 구하는 함수를 재귀 함수로 하면 문제점 존재
      - 엄청난 중복 호출이 존재한다!
      - 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다. 동적 계획법의 핵심
        ```py
        #memo를 위한 배열을 할당하고 모두 0으로 초기화
        ``` 

# 2023-08-10-목: Stack2

### DP(Dynamic Programming)
  - 동적계획 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.
  - 동적계획 알고리즘은 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.
  - 피보나치 수 DP적용
    - 부분 문제의 답으로 본 문제의 답을 얻을 수 있으므로 최적 부분 구조로 이루어져 있다.
      - 1. 부분 문제로 분할 한다
      - 2. 작은 부분문제 부터 해를 구한다.
      - 3. 그 결과는 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용해 상위 문제의 해를 구한다.
        ```py
        def fibo(n):
          f = [0] * (n + 1)
          f[0] = 0
          f[1] = 1
          for i in range(2, n + 1):
            f[i] = f[i-1] + f[i-2]
          
          return f[n]
        ``` 

### DFS(Depth First Search): 깊이 우선 탐색
  - 비선형 구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요
    - 두가지 방법이 있음 ( BFS / DFS )
  - Stack을 사용해서 DFS를 구현할 수 있음.
  - 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳 까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
  - 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용
    - 1. 시작 정점 v를 결정하여 방문한다.
    - 2. 정점 v에 인접한 정점 중에서
      - 1. 방문하지 않은 정점 W가 있으면, 정점 v를 스택에 push하고 정점 w를 방문한다. 그리고 w를 v로 하여 다시 2.를 반복한다.
      - 2. 방문하지 않은 정점이 없으면 ,탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다서 2.를 반복
    - 3. 스택이 공백이 될 때까지 2를 반복한다.(더이상 갈림길이 없을 떄)
      ```py
      visited[], stack[] 초기화
      DFS(v):
        시작점 v 방문
        visited[v] <- True
        while{
          if(v의 인접 정점 중 방문 안 한 정점 w가 있으면):
            push(v)
            v <- w (w에 방문)
            visited[w] <- True
          else:
            if(스택이 비어 있지 않으면):
              v <- pop(stack);
            else:(스택이 비었다면)
              break
        }
      ```
  - 초기상태: 배열 visited를 False로 초기화하고, 공백 스택을 생성
    - 1. 정점 A를 시작으로 깊이 우선 탐색을 시작
      ```py
      visited[A] = True 
      ```
    - 2. 정점 A에 방문하지 않은 정점 B, C가 있으므로 A를 스택에 push하고, 인접정점 B와 C중에서 오름차순에 따라 B를 선택하여 탐색을 계속한다.
      ```py
      # A 기록
      push(A)
      # B 방문
      visited[B] = True
      ``` 
    - 3. 정점 B에 방문하지 않은 정점 D, E가 있으므로 B를 스택에 push하고, 인접정점 D와 E 중에서 오름차순에 따라 D를 선택하여 탐색을 계속한다.
      ```py
      # B 기록
      push(B)
      # D 방문
      visited[D] = True
      ``` 
    - 4. 정점 D에 방문하지 않은 정점 F가 있으므로 D를 스택에 push하고, 인접정점 F를 선택하여 탐색을 계속한다.
      ```py
      # D 기록
      push(D)
      # F 방문
      visited[F] = True
      ``` 
    - 5. 정점 F에 방문하지 않은 E,G 중에서 F를 스택하고 E를 선택하여 탐색을 계속
      ```py
      # F 기록
      push(F)
      # E 방문
      visited[E] = True
      ``` 
    - 6. 정점 E에서 방문하지 않은 C를 탐색
      ```py
      # E 기록
      push(E)
      # C 방문
      visited[C] = True
      ```  
    - 7. 인접한 정점 중에 방문하지 않은 정점이 없음, 마지막 정점으로 돌아가기 위해 스택에서 pop 하며 인접정점을 확인 (뒷걸음질)
      ```py
      pop(stack)
      ``` 
    - 8. 계속해서 돌아감 F까지 돌아오면 인접정점 G가 존재함
      ```py
      push(F)
      # G 방분
      visited[G] = True
      ``` 
    - 9. 갈 수 있는 곳이 없으니 계속해서 pop(stack이 비워질 때 까지)

### 그래프 정리
  - 아이템들 간의 **연결관계**
  - 정점(Vertex)들의 집합과 이들을 연결해주는 간선(Edge) 들의 집합
  - 'V': 정점의 갯수
  - 'E': 간선의 갯수
  - 선형 자료 구조에서 나타내기 힘든 N:M 관계를 표현이 가능하다.
  - 인접행렬
    - 특정 노드에서 연결된 노드의 정보
  - ##### 왜 Stack을 활용하는가?
    - "내가 돌아갈 곳을 저장해 놓는 것" == Stack을 활용
    - 그래프를 표현하는 방법(인접행렬)
    1. 딕셔너리 활용
     ```py
     
     graph = {}
     graph['A'] = ['B', 'C']
     graph['B'] = ['D', 'E']
     ```

# 2023-08-14-월: Stack2

### 계산기
  - 문자열로 된 계산식이 주어질 때, 스택을 활용을 이용하여 계산식의 값을 계산.
  - 문자열 수식 계산의 일반적 방법
    - step1. 중위 표기법의 수식을 후위표기법으로 변경한다.(스택 이용)
      - 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현한다. (계산의 우선순위)
      - 각 연산자를 그에 대응하는 오른쪽괄호의 뒤로 이동시킨다.
      - 괄호를 제거한다.

    - step2. 후위 표기법의 수식을 스택을 이용하여 계산한다.
      - 계산의 순서를 단순화 하기 좋음
      - 피연산자를 만나면 스택에 push한다.
      - 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고, 연산결과를 다시 스택에 push한다.
      - 수식이 끝나면, 마지막으로 스택을 pop하여 출력한다.
  
### 백트래킹
  - 해를 찾는 도중에 '막히면' 되돌아가서 다시 해를 찾아 가는 기법이다.
  - 백트래킹 기법은 최적화문제와 결정문제를 해결할 수 있다.
  - 결정 문제: 문제의 조건을 만족하는 해가 존재하는지의 여부를 'yes' 또는 'no'로 답하는 문제
    - 미로 찾기
      - 입구와 출구가 주어진 미로에서 입구부터 출구까지의 경로를 찾는 문제이다.
      - 이동할 수 있는 방향은 4방향으로 제한한다.
      - 스택을 이용하여 지나온 경로를 역으로 되돌아 간다.
      - 스택을 이용하여 다시 경로를 찾는다.
    - n-Queen 문제
    - map coloring
    - 부분 집합의 합 문제 등

  #### 백트래킹과 깊이우선탐색과의 차이
   - 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임.
   - 깊이우선탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단.
   - 깊이우선탐색을 가하기에는 경우의 수가 너무나 많음. 즉 N!가지의 경우의 수를 가진 문제에 대해 깊이우선탐색을 가하면 당연히 처리 불가능한 문제
   - 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 지수함수 시간을 요하므로 처리 불가능

  #### 백트래킹 기법
    - 어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가(backtracking) 다음 자식 노드로 감
    - 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다고 하며, 반대로 해답의 가능성이 있으면 유망하다고 한다.
    - 가지치기(pruning): 유망하지 않는 노드가 포함되는 경로는 더 이상 고려하지 않는다.

  #### 백트래킹 절차
    - 상태 공간 트리의 깊이 우선 검색을 실시한다.
    - 각 노드가 유망한지를 점검한다.
    - 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다.

  #### 일반 백트래킹 알고리즘
    - n-Queen: 일단 놓기전에 생각을 하고 놓기.
      ```py
      def checknode(v):
        if promising(v):
          if there is a solution at v:
            write the solution
          else:
            for u in each child of v:
              checknode(v)
      ```
    - 이런 유형의 경우 백트래킹 문제가 훨 씬 빠름.

  #### 부분집합 구하기
    - 어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합을 powerset이라고 하며 구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 개수는 2^n개 이다.
    - ##### 백트래킹 기법으로 powerset을 구하기.
      - 앞에서 설명한 일반적인 백트래킹 접근 방법을 이용한다.
      - n개의 원소가 들어있는 집합의 2^n개의 부분집합을 만들 때는, true 또는 false 두가지는 항목들로 구성된 n개의 배열을 만드는 방법을 이용
      - 여기서 배열의 i번째 항목은 i번째의 원소가 부분집합의 값인지 아닌지를 나타내느 값이다.
        ```py
        def backtrack(a, k, input):
          global MAXCANDIDATES
          c = [0] * MAXCANDIDATES

          if k == input:
            process_solution(a, k) # 답이면 원하는 작업을 한다
          else:
            k += 1
            ncandidates = construct_candidates(a, k ,input, c)
            for i in range(ncandidates):
              a[k] = c[i]
              backtrack(a, k, input)
        ```

# 2023-08-16 수: Stack2

### 부분집합
  - 집합 {1,2,3}의 원소에 대해 각 부분집합에서의 포함 여부를 트리로 표현
  - 재귀 1
    ```py
    def f(i, N):
    if i == N:
        return
    else:
        B[i] = A[i]
        f(i+1, N)
        return

    N = 3
    A = [1, 2, 3]
    B = [0] * N
    f(0, N)
    print(B)
    ```

  - 부분집합 재귀
    ```py 
    def f(i, N):
        if i == N:
            print(bit, end = ' ')
            for j in range(N):
                if bit[j]:
                    print(A[j], end = ' ')
            print()
            return
        else:
            bit[i] = 1
            f(i+1, N)
            bit[i] = 0
            f(i+1, N)
            return

    A = [1, 2, 3]
    bit = [0]*3
    f(0, 3)
    ```  

  - 부분집합의 합 재귀
    ```py
    # 부분집합의합 구하기 / 재귀
    def f(i, N):
        if i == N:
            print(bit, end = ' ')
            s = 0
            for j in range(N):
                if bit[j]:
                    s += A[j]
                    print(A[j], end = ' ')
            print(f': {s}')
            return
        else:
            bit[i] = 1
            f(i+1, N)
            bit[i] = 0
            f(i+1, N)
            return

    A = [1, 2, 3]
    bit = [0]*3
    f(0, 3)
     ```

  - 부분집합의 합 재귀2: 각 단계에서 가지치기 가능한 코드
    ```py
    # f(i, N, s): s: i-1 단계까지의 부분집합의 합

    # 부분집합의합 구하기 / 재귀2

    def f(i, N, s): # s: i-1 원소까지의 합(포함된 원소의 합)
        if i == N:
            print(bit, end = ' ')
            print(f': {s}')
            return
        else:
            bit[i] = 1 # A[i]가 포함이 되는 경우
            f(i+1, N, s+A[i])
            bit[i] = 0 # A[i]가 포함되지 않는 경우
            f(i+1, N, s)
            return

    A = [1, 2, 3]
    bit = [0]*3
    f(0, 3, 0)
    ```

  - 부분집합의 합 연습문제 / 가지치기 = 백트래킹
  - 1부터 10까지 원소인 집합, 부분집합의 합이 10인 경우?
    ```py
    
    # 부분집합의합 구하기 / 연습문제 / 백트래킹

    def f(i, N, s, t): # s: i-1 원소까지의 합(포함된 원소의 합), t: 찾으려는 합
        global cnt
        cnt += 1
        if s == t:  # 찾았으면 그만
            print(bit, s)
            return
        elif s > t:  # 합이 t보다 커지는 경우
            return
        elif i == N:   #  원소가 없는 경우
            return
        else:
            bit[i] = 1 # A[i]가 포함이 되는 경우
            f(i+1, N, s+A[i], t)
            bit[i] = 0 # A[i]가 포함되지 않는 경우
            f(i+1, N, s, t)
            return

    # 1부터 10까지 원소인 집합, 부분집합의 합이 10인 경우는??
    N = 10
    A = [i for i in range(1, N+1)]
    bit = [0] * N
    cnt = 0
    f(0, N, 0, 10) # 합이 10인 경우 가지치기
    print(cnt)
    ```

   - 백트래킹을 이용한 부분집합의 합
    ```py
    
    ```
### 순열
  -[1, 2, 3]의 모든 원소를 사용한 순열
    - 123, 132, 213, 231, 312, 321
      - 순열 1 (자기부터 시작해서 오른쪽과 자리바꾸기)

        ```py
        # 거듭제곱
        def f1(b, e):
            if b == 0:
                return 1
            r = 1
            for i in range(e):
                r *= b
            return r

        def f2(b, e):
            if b == 0 or e == 0:
                return 1
            r = 1
            if e % 2: # 홀수라면
                r = f2(b, (e-1)//2)
                return r*r*b
            else:
                r = f2(b, e//2)
                return r*r
        ```

### 분할정복 알고리즘
  - 분할: 해결할 문제를 여러 개의 작은 부분으로 나눈다.
  - 정복: 나눈 작은 문제를 각각 해결한다.
  - 통합: 해결된 해답을 모은다.
  - 분할정복 예제: 거듭 제곱
    ```py
    
    ```  

### 퀵정렬
  - 주어진 배열을 두 개로 분할하고, 각각을 정렬한다.

# 2023-08-17 목: Queue
  - 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료 구조
    - 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조
  - 선입선출 구조(FIFO)
  - 큐의 기본 연산
    - 두개의 위치(머리(Front), 꼬리(Rear)) 사용
    - 삽입: enQueue
    - 삭제: deQUeue
  - 큐의 연산 과정
    - 공백 큐 생성, front = rear = -1
    - 원소 A 삽입, rear += 1, Q[rear] = A
    - 원소 B 삽입, rear += 1, Q[rear] = A
    - 원소 반환/삭제, front += 1, s = Q[front] 

  ### 선형큐
    - 1차원 배열을 이용한 큐
      - 큐의 크기 = 배열의 크기
      - front: 저장된 첫 번째 원소의 인덱스
      - rear: 저장된 마지막 원소의 인덱스
    - 상태 표현
      - 초기 상태: front = rear = -1
      - 공백 상태: front == rear
      - 포화 상태: rear == n-1
    - enQueue
      ```py
      if isFull():
      else:
        rear += 1
        Q[rear] = item
      ``` 
    - deQueue
      ```py
      if isEmpty():
      else:
        front += 1

        return Q[front]
      ``` 
    - isEmpty():
      ```py
      def isEmpty():
        return front == rear
      ``` 
    - isFull()
      ```py
      def isFull():
        retunr rear == len(Q)-1
      ```
    - Qpeek(): 가장 앞에 있는 원소를 검색하여 반환하는 연산
      ```py
      def Qpeek():
        if isEmpty() : print("empty")
        else: return Q[front+1]
      ```

    - 선형 큐 이용시의 문제점
      - 잘못된 포화상태 인식: 배열에 앞부분에 활용할 수 있는 공간이 있음에도 불가하고 포화상태로 인식함.
      - 해결방법1
        - 매 연산이 이루어질 때마다 저장된 원소들을 배열의 앞부분으로 모두 이동시킴
        - 효율이 떨어짐
      - 해결방법2
        - 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 사용   

  ### 원형큐
    - 초기 공백 상태: front = rear = 0
    - Index의 순환
      - front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨 후, 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함
      - 이를 위해 나머지 연산자 mod를 사용함
    - front 변수는 포화 상태 구분을 위해 항상 빈자리로 둠
    - 삽입 위치: rear = (rear + 1)mod n
    - 삭제 위치: front = (front + 1)mod n

    - 초기 공백 큐 생상
      - 크기 n인 1차원 배열 생성
      - front 와 rear을 0으로 초기화

    - 공백상태 및 포화상태 검사
      - isEmpty()
        ```py
        def isEmpty():
          return front == rear
        ``` 
      - isFull()
        ```py
        def isFull():
          return (rear+1) % len(cQ) == front
        ``` 

  ### 우선순위큐
    - 우선순위를 가진 항목들을 저장하는 큐
    - FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다.
    - 적용분야
      - 시뮬레이션 시스템
      - 네트워크 트래픽 제어
      - 운영체제의 테스크 스케줄링

  ### 버퍼(큐의 활용)
    - 데이터를 한 곳에서 다른 한곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
    - 버퍼링: 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미

    - 버퍼의 자료 구조
      - 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용 된다.
      - 순서대로 입력/출력/전달 되어야 하므로 FIFO 방식의 자료구조인 큐가 활용 된다.

    - ##### 마이쮸 시뮬레이션


# 2023-08-18 금: Queue

- ### BFS(Breadth First Search)
  - 너비 우선 탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식.
  - 인접한 정점들에 대해 탐색한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 큐를 활용함.


- ### BFS 예제(최단거리, 비상연락망)
  - 1. Visited 배열 초기화
  - 2. Q 생성
  - 3. 시작점 enQueue, visit처리
  - 4. deQueue
  - 5. 인접점 enQueue, visit처리
  - 6. Queue가 빌 때 까지 4번으로 돌아가 반복
  - ** visited 배열에 추가될때 이전 노드의 visited값에 누적합을 함
  - ** -> 경로의 거리를 나타내 주기 위해서.

# 2023-08-21 월: Tree
  - 비선형 구조
  - 원소들 간에 1:n 관계를 가지는 자료구조
  - 원소들 간에 계층관계를 가지는 계층형 자료 구조
  - 상위 원소에서 하위 원소로 내려가면서 확장되는 트리모양의 구조

### 트리
  -  한 개 이상의 노드로 이루어진 유한 집합이며 다음 조건을 만족한다.
     -  노드 중 최상위 노드를 루트라 한다.
     -  나머지 노드들은 n개의 분리 집합 T1, ..., Tn으로 분리될 수 있다.
  -  이들은 각각 하나의 트리가 되며(재귀) 루트의 부 트리라 한다.
  -  노드: 트리의 원소
  -  간선: 노드를 연결하는 선. 부모 노드와 자식 노드를 연결
  -  루트 노드: 트리의 시작 노드
  -  형제 노드: 같은 부모 노드의 자식 노드들
  -  조상 노드: 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
  -  서브 트리: 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
  -  자손 노드: 서브 트리에 있는 하위 레벨의 노드들
  -  차수
     -  노드의 차수: 노드에 연결된 자식 노드의 수
     -  트리의 차수: 트리에 있는 노드의 차수 중에서 가장 큰 값
     -  단말 노드: 차수가 0인 노드, 자식 노드가 없는 노드
  -  높이
     -  노드의 높이: 루트에서 노드에 이르는 간선의 수. 노드의 레벨
     -  트리의 높이: 트리에 있는 노드의 높이 중에서 가장 큰 값. 최대 레벨

### 이진트리
  - 모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리
  - 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리
  - 레벨i 에서의 노드의 최대 개수는 2^i개
  - 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 갯수는 (h+1)개가 되며, 최대 갯수는 (2^(h+1) - 1)개가 된다.
  - ##### 포화 이진 트리
    - 모든 레벨에 노드가 포화상태로 차 있는 이진 트리
    - 높이가 h일 때, 최대의 노드 개수인 (2^(h+1) - 1)의 노드를 가진 이진 트리
    - 루트를 1번으로 하여 (2^(h+1) - 1)까지 정해진 위치에 대한 노드번호를 가짐
  - ##### 완전 이진 트리
    - 높이가 h이고 노드 수가 n개일 때, 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리  
  - ##### 편향 이진 트리
    - 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
      - 왼쪽 편향 이진 트리
      - 오른쪽 편향 이진 트리
  - ##### 이진트리 - 순회
    - 순회란 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말함. 트리는 비선형 구조이기 때문에 선형구조에서와 같이 선후 연결 관계를 알 수 없다.
    - 따라서 특별한 방법이 필요하다.
    - 3가지의 기본적인 순회 방법
      - 전위순회(preorder traversal): VLR
        - 부모노드 방문 후, 자식노드를 좌,우 순서로 방문한다.
          ```py
          def preorder_traverse(T):
            if T: # T is not None
              visit(T)
              preorder_traverse(T.left)
              preorder_traverse(T.right)
          ``` 
      - 중위순회(inorder trversal): LVR
        - 왼쪽 자식노드, 부모노드, 오른쪽 자식노드 순으로 방문한다.
          ```py
          def inorder_traverse(T):
             if T:
              inorder_traverse(T.left)
              visit(T)
              inorder_traverse(T.right)
          ``` 
      - 후위순회(postorder traversal): LRV
        - 자식노드를 좌우 순서로 방문한 후, 부모노드로 방문한다.
          ```py
          def postorder_traverse(T):
            if T:
              postorder_traverse(T.left)
              postorder_traverse(T.right)
              visit(T)
          ``` 


### 이진트리의 표현
  - 배열을 이용한 이진 트리의 표현
    - 이진 트리에 각 노드 번호를 다음과 같이 부여
    - 루트의 번호를 1로 함
    - 레벨 n에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2^n 부터 2^(n+1) -1 까지 번호를 차례로 부여
  - 노드 번호의 성질
    - 노드 번호가 i인 노드의 부모 노드 번호? i/2 에서 소수점 버림
    - 노드 번호가 i인 노드의 왼쪽 자식 노드 번호? i*2
    - 노드 번호가 i인 노드의 오른쪽 자식 노드 번호? i*2 + 1
    - 레벨 n의 노드 번호 시작 번호는? 2^n
    - 

# 2023-08-22 화: Tree

### 수식 트리
  - 수식을 표현하는 이진 트리
  - 연산자는 루트 노드이거나 가지노드
  - 피연산자는 모두 잎 노드


### 이진탐색 트리
  - 탐색작업을 효율적으로 하기 위한 자료구조
  - 모든 원소는 서로 다른 유일한 키를 갖는다
  - key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
  - 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리다.
  - 중위 순회히면 오름차순으로 정렬된 값을 얻을 수 있다.
  
  - 탐색연산
    - 루트에서 시작한다
    - 탐색할 키값 x를 루트 노드의 키 값과 비교한다
      - (키 값x = 루트노드의 키 값)인 경우: 원하는 원소를 찾았으므로 탐색연산 성공
      - (키 값x < 루트노드의 키 값)인 경우: 루트노드의 왼쪽 서브트리에 대해서 탐색 연산 수행
      - (키 값x > 루트노드의 키 값)인 경우: 루트노드의 오른쪽 서브트리에 대해서 탐색연산 수행
    - 서브트리에 대해서 순환적으로 탐색 연산을 반복한다.
  
  - 삽입연산
    - 먼저 탐색 연산을 수행
      - 삽입할 원소와 같은 원소가 트리에 있으면 삽입할 수 없으므로, 같은 원소가 트리에 있는지 탐색하여 확인한다.
      - 탐색에서 탐색 실패가 결정되는 위치가 삽입 위치가 된다.
    - 탐색 실패한 위치에 원소를 삽입한다. 


### 힙: 완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료구조
  - 최대 힙
    - 키값이 가장 큰 노드를 찾기 위한 완전 이진트리
    - {부모노드의 키값 > 자식노드의 키값}
    - 루트 노드: 키 값이 가장 큰 노드
  - 최소 힙
    - 키값이 가장 작은 노들르 찾기 위한 완전 이진 트리
    - {부보노드의 키값 < 자식 노드의 키값}
    - 루트 노드: 키값이 가장 작은 노드
  - 삭제
    - 힙에서는 루트 노드의 원소만을 삭제할 수 있다.
    - 루트 노드의 원소를 삭제하여 반환한다.
    - 힙의 종류에 따라 최대값 또는 최소값을 구할 수 있다.

# 2023-08-24-수: Start

### 비트 연산
  - 비트 연산자
    - &: 비트단위로 AND 연산을 한다.
    - |: 비트단위로 OR 연산을 한다.
    - ^: 비트단위로 XOR 연산을 한다.
    - ~: 단항 연산자로서 피연산자의 모든 비트를 반전시킨다.
    - '<<': 피연산자의 비트 열을 왼쪽으로 이동시킨다.
    - '>>': 피연산자의 비트 열을 오른쪽으로 이동시킨다.

  - 1 << n
    - 2^n의 값을 갖는다.
    - 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
    - Power set(모든 부분 집합)
      - 공집합과 자기 자신을 포함한 모든 부분집합
      - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산된다.
  
  - i & (1 << j)
    - 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미한다. 

# 2023-08-25-목: Start2

### 비트연산: 개어려운데 이거
  - 비트 연산 예제2: 16진수를 2진수로
    ```py
    def Bbit_print(i):
      output = ''
      for j in range(7, -1, -1):
        output += '1' if i & (1 << j) else '0'
      print(output, end='')
    
    a = 0x16
    x = 0x01020304
    ```
### 진수
  - 2진수, 10진수, 16진수를 중심으로
  - 10진수 -> 타 진수로 변환
    - 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.
  - 타진수 -> 10진수로 변환
    - 위에를 반대로
  - 소수점이 있는 경우는 -제곱으로 감.
  - 2진법 -> 16진법: 4자리씩 묶음
  - 2진법 -> 8진법: 3자리씩 묶음

  - 컴퓨터에서의 음의 정수 표현 방법
    - 1의 보수: 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은0으로 변환한다.
      - -6: 100000000000110: 부호와 절대값 표현
      - -6: 111111111001: 1의 보수 표현
    - 2의 보수: 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다.
      - -6: 1111111111111010: 2의 보수 표현


### 실수
  - 실수의 표현
    - 컴퓨터는 실수를 표현하기 위해 부동 소수점 표기법을 사용한다
    - 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다.
      -  소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현

# 2023-08-25-금


# 2023-08-30-수: 완전 검색 & 그리디

### 반복과 재귀: 유사한 작업을 수행할 수 있다.
  - 반복은 수행하는 작업이 완료될 때까지 계속 반복
  - 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
  - 재귀적 알고리즘
    - 재귀적 정의는 두 부분으로 나뉜다.
    - 하나 또는 그 이상의 기본 경우
      - 집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드 역할
    - 하나 또는 그 이상의 유도된 경우
      - 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법
  - 반복 함수
    - 주어진 조건내에서 동일한 작업을 계속 반복하는 함수
    ```py
    def selectionSort(A):
      n = len(A)

      for i in range(0, n-1):
        minI = i
        for j in range(i+1, n):
          if A[j] < A[minI]:
            minI = j
          A[minI], A[i] = A[i], A[minI]
    ```
  - 재귀 함수
    - 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수.
    - 반복구조에 비해 간결하고 이해하기 쉽니다.
    - 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다.
    - 팩토리얼 재귀함수
      ```py
      def fact(n):
        if n <= 1:
          return 1
        else:
          return n * fact(n-1)
      ```
    - 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스럼다
    - 입력 값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.

### 완전검색기법: 가능한 모든 경우를 탐색하는 방법
  - Baby-gin Game
  - 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것이다.

  #### 브루트 포스
    - 문제를 해결하기 위한 간단하고 쉬운 접근법이다.
    - 대부분의 문제에 적용 가능하다.
    - 상대적으로 빠른 시간에 문제 해결을 할 수 있다.
    - 문제에 포함된 자료의 크기가 작다면 유용하다.
    - 학술적 또는 교육적 목적을 위해 알고리즘의 효율성을 판단하기 위한 척도로 사용된다.
    - 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만. 해답을 찾아내지 못할 확률이 작다
    - 이를 기반으로 그리디 기법이나 동적 계획법을 이용해서 효율적인 알고리즘을 찾을 수 있다.

### 순열
  - 서로 다른 것들 중 몇개를 뽑아서 한줄로 나열 하는 것
  - n개 중에 r개를 뽑아 한줄로 나열 하는 것이면 n! / r! 으로 계산
  - n개의 요소들에 대해서 n!개의 순열들이 존재한다
  - n > 12인경우 시간 복잡도 폭발적으로 증가
  - 단순하게 순열을 생성하는 방법
    - 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop를 이용해 아래와 같이 구현할 수 있다.
  - 최소 변경을 통한 방법
    - 각각의 순열들을 이전의 상태에서 단지 두개의 요소들 교환을 통해 생성
  - 재귀 호출을 통한 순열 생성
    ```py
    // p[]: 데이터가 저장된 배열
    // k: 원소의 갯수, n: 선택된 원소의 수
    def perm(i, k):
      if i == k:
        print(arr)
      else:
        for j in range(i, k):
          p[i], p[j] = p[j], p[i]
          perm(i+1, k)
          p[i], p[j] = p[j], p[i]
    ```
  - used 배열을 사용한 방식.
  - 사용하지 않은 애를 찾아서 순서대로 활용하는 방식
    ```py
    //p[]: 순열을 저장하는 배열, arr[i]: 순열을 만드는데 사용할 숫자 배열
    // n: 원소의 갯수, i: 선택된 원소의 수
    // used[N-1]: 사용여부, p:결과저장 배열
    perm(i, k)
      if(i==k) print_arr
    
    ``` 

### 부분집합: 집합에 포함된 원소들을 선택하는 것이다.
  - 단순하게 모든 부분 집합 생성하는 방법
    - 다중 for 문을 이용해서 만들기
  - 바이너리 카운팅을 통한 사전적 순서
    - 부분집합을 생성하기 위한 가장 자연스러운 방법
    - 이진수를 사용해서 n번째 원소가 포함되었음을 확인한다.
    ```py
    arr = [3, 6, 7, 1, 5, 4]
    n = len(arr)

    for i in range(0, (1<<n)):
    ``` 

# 2023-08-31-목: 그리디 & 완탐

### 조합: 서로다른 n개의 원소 중 r개를 순서 없이 골라낸 것.
  - 재귀 호출을 이용한 조합 생성 알고리즘
    ```py
    ar[]: n개의 원소를 가지고 있는 배열
    tr[]: r개의 크기의 배열, 조합이 임시 저장될 배열

    comb(n, r)
      if(r==0) print_arr()
      else if (n<r) return
      else
        tr[r-1] = an[n-1]
        comb(n-1, r-1)
        comb(n-1, r)
    ``` 
  - 10개의 원소 중 3개를 고르는 조합(i< j < k)
    ```py
    for i: 0 -> 7
      for j: i+1 -> 8
        for k: j+1 -> 9
          f(a[i], a[j], a[k])
    ``` 
  - n개에서 r개를 고르는 조합(재귀)
    ```py
    def nCr(n,r,s): # n개에서 r개를 고르는 조합, s 선택할 수 있는 구간의 시작
      if r == 0:
        print(*comb)
      else:
        for i in range(s, n-r+1):
          comb[r-1] = A[i]
          nCr(n, r-1, i+1)
    ``` 

### 탐욕알고리즘: 최적해를 구하는데 사용되는 근시안적인 방법
  - 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합에 추가한다
  - 실행 가능성 검사: 새로운 부분 해 집합이 실행가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는 지를 검사한다.
  - 해 검사: 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.

  - 배낭 짐싸기 문제
    - 배낭이 담을 수 있는 물건의 총 무게 W는 정해져있음
    - 창고에는 n개의 물건들이 있고 각각의 물건에는 무게와 값이 정해져있음
    - 무게를 초과하지 않으면서 값이 최대가 되는 물건들을 담아야 함.
  
  - 1. 완전탐색을 이용함
    - 부분집합 S를 구한 다음 총 무게 W를 초과하는 집합은 버림, 나머지에서 총 값이 가장 큰 집합을 선택
  - 2. 그리디를 이용함(물건을 자를 수 있는 경우)

### 활동 선택 문제(회의실 배정하기 문제)
  - 서로 겹치지 않는 최대 갯수의 활동들의 집합 S를 구하는 문제
  - 가능한 모든 부분집합 중 최대갯수가 되는 경우를 찾기
  - 

### Baby-Jin